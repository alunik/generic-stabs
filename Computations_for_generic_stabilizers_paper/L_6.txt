/*
Let P_3 = G_<e1,e2,e3> and n = n3 or n1n2n3n2n1n2n3n2, so that 
P_3^n is the stabilizer of <e1,e2,f3> or <e3,f1,f2>.
The following function is a wrapper for the routine of finding the Groebner basis
of the system of polynomials that determine the stabilizer in P_3^n of W^*.
The variable field can be Rationals() or a finite field, while j is an integer 
between 1 and 6, corresponding to the 6 possibilities for the Bruhat
decomposition of an element in P_3. If field == Rationals(), the function also returns
a list of primes that need to be checked individually.
*/

findGroebnerBasis := function(field, j)
	
	// Define the group and the representation. 
    R<a1, a2, a3, a4, a5, a6, a7, a8, a9, b1, b2, b3, b4, b5, b6, b7, b8, b9, 
       t1, t2, t3, t1inv, t2inv, t3inv, om, i> := PolynomialRing(field, 26);
    F<a1_f, a2_f, a3_f, a4_f, a5_f, a6_f, a7_f, a8_f, a9_f, b1_f, b2_f, b3_f, b4_f, 
       b5_f, b6_f, b7_f, b8_f, b9_f, t1_f, t2_f, t3_f, t1inv_f, t2inv_f, t3inv_f, 
       om_f, i_f> := FieldOfFractions(R);
    C := GroupOfLieType("C3", F : Isogeny := "SC");
    f := HighestWeightRepresentation(C, [0, 1, 0]);

    V3 := VectorSpace(F, 3);
    V := VectorSpace(F, 14);

    v1 := V.8 - om^2 * V.7;
    v2 := V.5 - i * V.6;
    v3 := V.4 + i * V.3;
    v4 := V.14 - i * V.2;
    v5 := V.1 - i * V.13;
    v6 := V.11 + i * V.12;
    v7 := V.10 + i * V.9;

    // Here Wdd is the subspace W^\ddag, while the span of all 7 vectors v1,...,v7 is W^*.
    Wdd := sub<V | v1, v2, v3, v5>;

    // Extend the basis for Wdd to a basis for the whole module
    B := [v1, v2, v3, v5, V.8, V.6, V.4, V.13, V.2, V.9, V.10, V.11, V.12, V.14];
    VB := VectorSpaceWithBasis(B);

    // Define the list of (preimages) of Weyl group elements that belong to P_3
    ns := [Identity(C), elt<C | 1>, elt<C | 2>, elt<C | 1, 2>, 
           elt<C | 2, 1>, elt<C | 1, 2, 1>];
    // Each such Weyl group element has a corresponding u^-, generated by positive root elements
    // that are sent to negative root elements by the Weyl group element.
    u_minuss := [Identity(C), elt<C | <1, b9>>, elt<C | <2, b7>>, 
    			 elt<C | <2, a7>, <4, a8>>,
                 elt<C | <4, b8>, <1, b9>>,  
                 elt<C | <2, a7>, <4, a8>, <1, a9>>];
    n := ns[j];
    u_minus := u_minuss[j];

    // Write an arbitrary element g belonging to the double coset B n B.
    g := elt<C | <3, a1>, <5, a2>, <7, a3>, <6, a4>, <8, a5>, <9, a6>, 
             <2, a7>, <4, a8>, <1, a9>, V3![t1, t2, t3]> * n * u_minus;
             
    // Conjugate by either n3 or n2n3n2n1n2n3n2n1 to get an arbitrary element of G_<e1,e2,f3> or G_<e3,f1,f2>
    g := g^elt<C | 3>;

    // Initialise the list of polynomials, encoding the fact that the ti's are non-zero,
    // and that om and i are primitive fourth and third roots of unity respectively.
    polys := {t1_f * t1inv_f - 1, t2_f * t2inv_f - 1, t3_f * t3inv_f - 1, om_f + om_f^2 + 1, i_f^2 + 1};

    // Complete set of polynomials by adding the conditions required for g to fix Wdd
    for v in Basis(Wdd) do
        for poly in Coordinates(VB, v * f(g))[5..14] do
            Include(~polys, poly);
        end for;
    end for;

    // If field is finite, output the Groebner basis
    if IsFinite(field) then
        A1, A2 := GroebnerBasis([Numerator(p) : p in polys]);
        return A1;
    end if;

    // Otherwise also output the list of primes the F4 algorithm divided by. These
    // need to be checked individually by running the function again.
    if field eq Rationals() then 
        SetGBGlobalModular(false);
        A1, A2, A3 := GroebnerBasis([Numerator(p) : p in polys] : ReturnDenominators := true);
        return A1, A3;
    end if;

end function;
